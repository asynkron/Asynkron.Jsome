# Asynkron.Jsome

A C# code generator that converts Swagger 2.0 JSON files and JSON Schema directories into clean C# DTO classes and FluentValidation validators. Perfect for generating type-safe C# code from OpenAPI specifications.

## Installation

Install Asynkron.Jsome as a .NET global tool:

```bash
# Install the global tool
dotnet tool install -g dotnet-jsome

# Update to the latest version
dotnet tool update -g dotnet-jsome
```

**Requirements:** .NET 8.0 Runtime or SDK

## Standard Use Case

The most common use case is generating C# DTOs from a Swagger 2.0 specification:

### Quick Start

```bash
# Generate from Petstore sample (built-in)
jsome

# Generate from your own Swagger file
jsome my-api-spec.json

# Generate from a URL
jsome https://petstore.swagger.io/v2/swagger.json
```

### Example Output

**Input Swagger Schema:**
```json
{
  "User": {
    "type": "object",
    "properties": {
      "id": { "type": "integer", "format": "int64" },
      "name": { "type": "string" },
      "email": { "type": "string", "format": "email" }
    },
    "required": ["id", "name"]
  }
}
```

**Generated C# DTO:**
```csharp
using System.ComponentModel.DataAnnotations;
using Newtonsoft.Json;

namespace Generated;

public partial class User
{
    [JsonProperty("id")]
    [Required]
    public long Id { get; set; }

    [JsonProperty("name")]
    [Required]
    public string Name { get; set; }

    [JsonProperty("email")]
    public string Email { get; set; }
}
```

**Generated FluentValidator:**
```csharp
using FluentValidation;

namespace Generated.Validators;

public class UserValidator : AbstractValidator<User>
{
    public UserValidator()
    {
        RuleFor(x => x.Id).NotEmpty();
        RuleFor(x => x.Name).NotEmpty();
    }
}
```

## Tweaking the Standard Use Case

### Common Customizations

```bash
# Specify output directory and namespace
jsome my-api.json --output ./Generated --namespace MyProject.DTOs

# Use System.Text.Json instead of Newtonsoft.Json
jsome my-api.json --system-text-json

# Generate modern C# with nullable types and required keyword
jsome my-api.json --modern

# Generate C# records instead of classes
jsome my-api.json --modern --records

# Skip confirmation prompts
jsome my-api.json --yes
```

### Configuration Files

For more control, use a configuration file to customize generation:

**config.yaml:**
```yaml
global:
  namespace: "MyApi.Generated"
  generateEnumTypes: true

rules:
  # Exclude sensitive properties
  "User.Password":
    include: false
  
  # Custom validation
  "User.Email":
    validation:
      required: true
      pattern: "^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$"
      message: "Please enter a valid email address"
```

**Usage:**
```bash
jsome my-api.json --config config.yaml --output ./Generated
```

---

## Advanced Features

#### Default Usage (Petstore Sample)

```bash
jsome
```

#### With Custom Swagger File

```bash
# Use a relative path
jsome my-api-spec.json

# Use an absolute path  
jsome /path/to/swagger.json

# Use a remote URL
jsome https://petstore.swagger.io/v2/swagger.json
```

#### With JSON Schema Directory (New!)

SwaggerGen now supports generating DTOs from multiple JSON Schema files in a directory, perfect for vanilla JSON Schema compatibility (such as OCPP 1.6):

```bash
# Generate from all JSON Schema files in a directory
jsome generate --schema-dir /path/to/schemas

# With custom namespace and output directory
jsome generate --schema-dir ./schemas --namespace MyProject.Generated --output ./generated

# Real-world example with OCPP 1.6 schemas
jsome generate --schema-dir ./schemas/ocppv16/json_schemas --namespace OCPP.V16.Generated --output ./src/Generated
```

#### Command Line Options

```
Usage: jsome generate [options] [swagger-file-path]

Arguments:
  swagger-file-path                     Path to a Swagger 2.0 JSON file (optional)

Options:
  -s, --schema-dir <schema-dir>         Directory containing multiple JSON Schema files to process
  -c, --config <config>                 Path to YAML or JSON configuration file 
  -n, --namespace <namespace>           Override the default namespace for generated code
  -o, --output <output>                 Output directory for generated files
  -y, --yes                            Skip confirmation prompts 
  -t, --template-dir <template-dir>     Custom directory containing Handlebars template files
  -m, --modern                         Enable modern C# features (nullable types, required keyword)
  --records                            Generate C# records instead of classes for DTOs
  --system-text-json                   Use System.Text.Json attributes instead of Newtonsoft.Json
  --swashbuckle-attributes             Generate Swashbuckle.AspNetCore.Annotations attributes
  --proto                              Generate Protocol Buffers (.proto) files in addition to C# code
  --templates                          Specify custom template files to use (e.g., --templates DTO.hbs MyCustom.hbs)
  -h, --help                           Show help information

Examples:
  jsome generate
  jsome generate petstore-swagger.json
  jsome generate /path/to/my-api.json
  jsome generate --schema-dir ./json-schemas --namespace MyApi.Generated
  jsome generate --config config.yaml --output ./generated --modern
  jsome generate petstore-swagger.json --swashbuckle-attributes --output ./generated
  jsome generate --proto --output ./generated --namespace MyProtos
```

## Protocol Buffers (.proto) Generation

Asynkron.Jsome can generate Protocol Buffers definitions alongside C# code, enabling cross-language compatibility and efficient serialization.

### Usage

Enable Protocol Buffers generation with the `--proto` flag:

```bash
# Generate both C# and .proto files
jsome generate my-api.json --proto --output ./generated

# Generate only .proto files using custom templates
jsome generate my-api.json --templates proto.hbs proto.enum.hbs --output ./generated
```

### Generated Protocol Buffers Output

For each Swagger definition, Asynkron.Jsome generates corresponding `.proto` files:

**Input Swagger Schema:**
```json
{
  "User": {
    "type": "object",
    "properties": {
      "id": {
        "type": "integer",
        "format": "int64",
        "description": "User ID"
      },
      "name": {
        "type": "string",
        "description": "User name"
      },
      "email": {
        "type": "string",
        "format": "email"
      },
      "isActive": {
        "type": "boolean",
        "description": "User status"
      }
    },
    "required": ["id", "name"]
  }
}
```

**Generated Protocol Buffers (.proto):**
```protobuf
syntax = "proto3";

// User definition
message User {
  // User ID
  int64 id = 1;
  // User name  
  string name = 2;
  // 
  string email = 3;
  // User status
  bool is_active = 4;
}
```

### Protocol Buffers Features

- **Automatic Type Mapping**: Converts C# types to appropriate Protocol Buffers types
- **Field Numbering**: Sequential field numbering starting from 1
- **Snake Case Conversion**: Converts C# property names to snake_case for proto compatibility
- **Enum Support**: Generates proto enums with required UNSPECIFIED values
- **Comments Preservation**: Maintains descriptions from Swagger schemas

### Type Mapping

| Swagger Type | C# Type | Protocol Buffers Type |
|--------------|---------|----------------------|
| `string` | `string` | `string` |
| `integer` | `int` | `int32` |
| `integer` (int64) | `long` | `int64` |
| `number` | `double` | `double` |
| `number` (float) | `float` | `float` |
| `boolean` | `bool` | `bool` |
| `array` | `List<T>` | `repeated T` |

## F# Code Generation

Generate F# record types and modules from your Swagger specifications using custom Handlebars templates.

### F# Record Templates

Create F# record types with validation attributes:

**Template: `FSharp.hbs`**
```handlebars
---
extension: fs
description: F# record type template
---
namespace {{Namespace}}

open System.ComponentModel.DataAnnotations
{{#if UseSystemTextJson}}
open System.Text.Json.Serialization
{{else}}
open Newtonsoft.Json
{{/if}}

/// <summary>
/// {{Description}}
/// </summary>
type {{ClassName}} = {
{{#each Properties}}
    /// <summary>
    /// {{Description}}
    /// </summary>
    {{#if JsonPropertyName}}
    {{#if UseSystemTextJson}}
    [<JsonPropertyName("{{JsonPropertyName}}")>]
    {{else}}
    [<JsonProperty("{{JsonPropertyName}}")>]
    {{/if}}
    {{/if}}
    {{#if IsRequired}}
    [<Required>]
    {{/if}}
    {{Name}}: {{{Type}}}
{{/each}}
}
```

**Usage:**
```bash
# Generate F# record types
jsome generate my-api.json --templates FSharp.hbs --output ./generated

# Generate F# with System.Text.Json support
jsome generate my-api.json --templates FSharp.hbs --system-text-json --output ./generated
```

**Generated F# Output:**
```fsharp
namespace Generated

open System.ComponentModel.DataAnnotations
open Newtonsoft.Json

/// <summary>
/// User definition
/// </summary>
type User = {
    /// <summary>
    /// User ID
    /// </summary>
    [<JsonProperty("id")>]
    [<Required>]
    Id: int64
    /// <summary>
    /// User name
    /// </summary>
    [<JsonProperty("name")>]
    [<Required>]
    Name: string
    /// <summary>
    /// </summary>
    [<JsonProperty("email")>]
    Email: string
}
```

### F# Module Templates

Generate F# modules with validation functions:

**Template: `FSharpModule.hbs`**
```handlebars
---
extension: fs
description: F# module with validation template
---
namespace {{Namespace}}

/// <summary>
/// {{Description}}
/// </summary>
module {{ClassName}} =

    type {{ClassName}} = {
{{#each Properties}}
        {{Name}}: {{{Type}}} option
{{/each}}
    }

    /// Create a new {{ClassName}} with default values
    let create{{ClassName}} () = {
{{#each Properties}}
        {{Name}} = None
{{/each}}
    }

    /// Validate {{ClassName}} instance
    let validate (instance: {{ClassName}}) =
        let errors = ResizeArray<string>()
        
{{#each Properties}}
{{#if IsRequired}}
        if instance.{{Name}}.IsNone then
            errors.Add("{{Name}} is required")
{{/if}}
{{/each}}
        
        if errors.Count = 0 then Ok instance else Error (List.ofSeq errors)
```

**Generated F# Module:**
```fsharp
namespace Generated

/// <summary>
/// User definition
/// </summary>
module User =

    type User = {
        Id: int64 option
        Name: string option
        Email: string option
    }

    /// Create a new User with default values
    let createUser () = {
        Id = None
        Name = None
        Email = None
    }

    /// Validate User instance
    let validate (instance: User) =
        let errors = ResizeArray<string>()
        
        if instance.Id.IsNone then
            errors.Add("Id is required")
        if instance.Name.IsNone then
            errors.Add("Name is required")
        
        if errors.Count = 0 then Ok instance else Error (List.ofSeq errors)
```

## Handlebars Template System

Asynkron.Jsome uses Handlebars.NET for powerful, flexible code generation with custom templates.

### Template Structure

Templates support frontmatter for metadata and configuration:

```handlebars
---
extension: fs
description: F# record type template
---
{{! Template content goes here }}
namespace {{Namespace}}

type {{ClassName}} = {
{{#each Properties}}
    {{Name}}: {{{Type}}}
{{/each}}
}
```

### Frontmatter Options

| Property | Description | Default |
|----------|-------------|---------|
| `extension` | File extension for generated files | `cs` |
| `description` | Template description | None |

### Available Handlebars Helpers

Asynkron.Jsome provides custom Handlebars helpers for advanced code generation:

#### `{{add}}`
Adds two numbers together (useful for field numbering):
```handlebars
{{! Generates field numbers starting from 1 }}
{{proto_type Type}} {{snake_case Name}} = {{add @index 1}};
```

#### `{{snake_case}}`
Converts strings to snake_case format:
```handlebars
{{! Converts "MyPropertyName" to "my_property_name" }}
{{snake_case PropertyName}}
```

#### `{{proto_type}}`
Converts C# types to Protocol Buffers types:
```handlebars
{{! Converts "int" to "int32", "long" to "int64", etc. }}
{{proto_type Type}} {{snake_case Name}} = {{add @index 1}};
```

### Template Context Variables

Templates have access to rich context data:

#### Global Context
- `{{Namespace}}` - Target namespace
- `{{ClassName}}` - Current class name
- `{{Description}}` - Class description

#### Property Context (within `{{#each Properties}}`)
- `{{Name}}` - Property name
- `{{Type}}` - Property type (raw)
- `{{{Type}}}` - Property type (unescaped for generics)
- `{{Description}}` - Property description
- `{{JsonPropertyName}}` - JSON property name
- `{{IsRequired}}` - Whether property is required
- `{{DefaultValue}}` - Default value if any
- `{{MaxLength}}` - Maximum length constraint
- `{{MinLength}}` - Minimum length constraint
- `{{EnumValues}}` - Array of enum values (if applicable)
- `{{EnumTypeName}}` - Enum type name (if applicable)
- `{{ConstantsClassName}}` - Constants class name (if applicable)

#### Conditional Flags
- `{{UseSystemTextJson}}` - Whether to use System.Text.Json
- `{{UseSwashbuckleAttributes}}` - Whether to include Swashbuckle attributes
- `{{UseRequiredKeyword}}` - Whether to use C# `required` keyword
- `{{UseNullableReferenceTypes}}` - Whether to use nullable reference types

### Custom Template Development

Create your own templates for any target language or framework:

1. **Create Template File** (e.g., `MyCustom.hbs`):
```handlebars
---
extension: kt
description: Kotlin data class template
---
package {{Namespace}}

import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName

/**
 * {{Description}}
 */
@Serializable
data class {{ClassName}}(
{{#each Properties}}
    @SerialName("{{JsonPropertyName}}")
    val {{Name}}: {{Type}}{{#if DefaultValue}} = {{DefaultValue}}{{/if}}{{#unless @last}},{{/unless}}
{{/each}}
)
```

2. **Use Custom Template**:
```bash
jsome generate my-api.json --templates MyCustom.hbs --output ./generated
```

### Template Discovery

Templates are discovered in the following order:

1. **Custom Template Directory** (`--template-dir` option)
2. **Current Working Directory**
3. **Built-in Templates** (embedded in the application)

### Built-in Templates

Asynkron.Jsome includes these built-in templates:

| Template | Description | Extension |
|----------|-------------|-----------|
| `DTO.hbs` | C# class template | `.cs` |
| `DTORecord.hbs` | C# record template | `.cs` |
| `Validator.hbs` | FluentValidation validator | `.cs` |
| `Enum.hbs` | C# enum template | `.cs` |
| `Constants.hbs` | C# constants class | `.cs` |
| `proto.hbs` | Protocol Buffers message | `.proto` |
| `proto.enum.hbs` | Protocol Buffers enum | `.proto` |
| `proto.string_enum.hbs` | Protocol Buffers string enum | `.proto` |

### Example Templates

The repository includes example templates for other languages:

| Template | Description | Language |
|----------|-------------|----------|
| `FSharp.hbs` | F# record types | F# |
| `FSharpModule.hbs` | F# modules with validation | F# |
| `TypeScript.hbs` | TypeScript interfaces | TypeScript |

These templates demonstrate the flexibility of the Handlebars system and can be used as starting points for your own custom templates.

### JSON Schema Directory Features

The `--schema-dir` option provides powerful support for vanilla JSON Schema files:

- **Multiple File Processing**: Automatically loads and processes all `.json` files in the specified directory
- **Schema Merging**: Combines multiple schemas into a unified model for DTO generation
- **Internal Definitions**: Extracts and merges definitions from within individual schema files  
- **Conflict Detection**: Detects and reports conflicting type definitions across files
- **Cross-Reference Resolution**: Resolves `$ref` references across multiple schema files
- **JSON Schema Compatibility**: Supports vanilla JSON Schema features like boolean `additionalProperties`
- **Deduplication**: Automatically deduplicates identical type definitions by name

#### Limitations and Caveats

When using `--schema-dir` with vanilla JSON Schema files:

- Only JSON Schema Draft 4+ features commonly supported by Swagger are fully supported
- Complex JSON Schema features like `anyOf`, `oneOf`, and advanced conditionals may not be fully supported
- Schema titles are used as type names when available, otherwise filenames are used
- All schemas are merged into a single namespace - use prefixes in schema titles to avoid conflicts

## Development

If you want to contribute to SwaggerGen or run it from source:

### Prerequisites

- .NET 8.0 SDK

### Building

```bash
# Clone the repository
git clone https://github.com/asynkron/SwaggerGen.git
cd SwaggerGen

# Build the solution
dotnet build

# Run tests
dotnet test

# Run from source
dotnet run --project src/SwaggerGen
```

## Modifier Configuration

SwaggerGen supports advanced object graph control through YAML or JSON configuration files. This allows you to:

- Include or exclude specific properties and classes
- Override validation rules and messages
- Map types to custom C# types  
- Customize descriptions and default values
- Control the entire generation process

### Configuration File Format

Configuration files can be in YAML (.yml, .yaml) or JSON (.json) format:

#### YAML Example (`config.yaml`)

```yaml
# Global settings
global:
  namespace: "MyApi.Generated"
  generateEnumTypes: true
  defaultInclude: true
  includeDescriptions: true
  maxDepth: 8
  typeNamePrefix: "Api"      # Optional: Prefix for all type names
  typeNameSuffix: "DTO"      # Optional: Suffix for all type names

# Property-specific rules
rules:
  # Exclude sensitive properties
  "User.Password":
    include: false
  
  "Customer.CreditCard.Number":
    include: false

  # Custom validation for product names
  "Order.OrderDetail.Product.Name":
    include: true
    description: "Product name with enhanced validation"
    validation:
      required: true
      maxLength: 100
      pattern: "^[A-Za-z0-9\\s]+$"
      message: "Product name must contain only alphanumeric characters and spaces"

  # Type mapping for dates
  "Order.CreatedDate":
    include: true
    type: "DateTime"
    format: "yyyy-MM-dd'T'HH:mm:ss.fff'Z'"
    description: "Order creation timestamp"

  # Enhanced price validation
  "Product.Price":
    include: true
    validation:
      required: true
      minimum: 0.01
      maximum: 99999.99
      message: "Price must be between $0.01 and $99,999.99"
```

#### JSON Example (`config.json`)

```json
{
  "global": {
    "namespace": "MyApi.Generated",
    "generateEnumTypes": true,
    "defaultInclude": true,
    "includeDescriptions": true,
    "maxDepth": 8,
    "typeNamePrefix": "Api",
    "typeNameSuffix": "DTO"
  },
  "rules": {
    "User.Password": {
      "include": false
    },
    "Order.OrderDetail.Product.Name": {
      "include": true,
      "description": "Product name with enhanced validation",
      "validation": {
        "required": true,
        "maxLength": 100,
        "pattern": "^[A-Za-z0-9\\\\s]+$",
        "message": "Product name must contain only alphanumeric characters and spaces"
      }
    },
    "Order.CreatedDate": {
      "include": true,
      "type": "DateTime",
      "format": "yyyy-MM-dd'T'HH:mm:ss.fff'Z'",
      "description": "Order creation timestamp"
    }
  }
}
```

### Using Configuration Files

#### Programmatic Usage

```csharp
using SwaggerGen;
using SwaggerGen.CodeGeneration;
using SwaggerGen.Configuration;

// Load configuration from file
var options = new CodeGenerationOptions
{
    ModifierConfigurationPath = "path/to/config.yaml",
    GenerateEnumTypes = true
};

// Or use configuration instance directly
var config = ConfigurationLoader.Load("config.yaml");
var options = new CodeGenerationOptions
{
    ModifierConfiguration = config,
    GenerateEnumTypes = true
};

var generator = new CodeGenerator(options);
var document = await SwaggerParser.ParseFileAsync("swagger.json");
var result = generator.GenerateCode(document, "MyApi.Generated");
```

### Property Path Syntax

Property paths use dot notation to specify the exact location in the object hierarchy:

- `"User"` - Targets the entire User class
- `"User.Name"` - Targets the Name property of User
- `"Order.OrderDetail"` - Targets the OrderDetail property of Order
- `"Order.OrderDetail.Product.Name"` - Targets the Name property of Product within OrderDetail within Order

### Configuration Options

#### Global Settings

- `namespace`: Override the target namespace for generated code
- `generateEnumTypes`: Enable/disable enum type generation
- `defaultInclude`: Default inclusion policy (default: true)
- `includeDescriptions`: Whether to include original descriptions
- `maxDepth`: Maximum depth for object graph traversal
- `typeNamePrefix`: Prefix to apply to all generated type names (DTOs, enums, constants)
- `typeNameSuffix`: Suffix to apply to all generated type names (DTOs, enums, constants)

#### Type Name Formatting

When `typeNamePrefix` and/or `typeNameSuffix` are specified, they are applied to all generated type names:

```yaml
global:
  typeNamePrefix: "Api"
  typeNameSuffix: "DTO"
```

This transforms type names as follows:
- `User` class becomes `ApiUserDTO`
- `OrderStatus` enum becomes `ApiOrderStatusDTO`
- `ProductCategoryConstants` class becomes `ApiProductCategoryConstantsDTO`
- All type references in generated code are automatically updated

**Note**: Property names are never affected by prefix/suffix - only type names change.

#### Property Rules

Each property rule can specify:

- `include`: Whether to include the property (boolean)
- `description`: Custom description override (string)
- `type`: Custom C# type mapping (string)
- `format`: Format specification (string)
- `default`: Default value override
- `validation`: Validation rule overrides (object)

#### Validation Overrides

- `required`: Whether the property is required (boolean)
- `minLength`/`maxLength`: String length constraints (integer)
- `minimum`/`maximum`: Numeric range constraints (decimal)
- `pattern`: Regular expression pattern (string)
- `message`: Custom validation message (string)

### Backward Compatibility

The modifier configuration system is fully backward compatible:

- **Missing `include`**: Defaults to `true` (included)
- **No configuration**: Behaves exactly like the original system
- **Partial configuration**: Only specified rules are applied, others use defaults
- **Legacy code**: Continues to work without any changes

## Modern C# Features

SwaggerGen supports modern C# language features that enable cleaner, more expressive code generation:

### Nullable Reference Types & Required Keyword

Use the `--modern` flag to enable nullable reference types and the `required` keyword:

```bash
jsome generate my-api.json --output ./Generated --modern
```

**Traditional approach (default):**
```csharp
public class User
{
    [Required]
    public string Name { get; set; }
    
    public string Email { get; set; }  // May be null but not explicitly marked
}
```

**Modern approach (`--modern`):**
```csharp
public class User
{
    public required string Name { get; set; }  // Uses 'required' keyword
    
    public string? Email { get; set; }         // Explicitly nullable
}
```

### C# Records

Generate immutable records using the `--records` flag:

```bash
jsome generate my-api.json --output ./Generated --modern --records
```

**Generated C# record:**
```csharp
public record User(
    [JsonProperty("id")] required int Id,
    [JsonProperty("name")] required string Name,
    [JsonProperty("email")] string? Email,
    [JsonProperty("age")] int? Age
);
```

### Feature Comparison

| Feature | Legacy | Modern Class | Modern Record |
|---------|--------|--------------|---------------|
| **Mutability** | Mutable | Mutable | Immutable |
| **Required Fields** | `[Required]` attribute | `required` keyword | `required` keyword |
| **Optional Fields** | Non-nullable | Nullable (`?`) | Nullable (`?`) |
| **Syntax** | Properties | Properties | Positional parameters |
| **Performance** | Standard | Standard | Optimized |
| **Equality** | Reference | Reference | Structural |

### CLI Options Summary

```bash
# Generate traditional classes (default)
jsome generate api.json --output ./Generated

# Generate modern classes with nullable types and required keyword
jsome generate api.json --output ./Generated --modern

# Generate modern records
jsome generate api.json --output ./Generated --modern --records

# View all available options
jsome generate --help
```

## Swashbuckle Attributes Support

SwaggerGen can generate **Swashbuckle.AspNetCore.Annotations** attributes alongside standard DataAnnotations to provide rich OpenAPI documentation in your ASP.NET Core applications.

### Usage

Enable Swashbuckle attributes generation with the `--swashbuckle-attributes` flag:

```bash
jsome generate petstore-swagger.json --swashbuckle-attributes
```

### Generated Attributes

When enabled, SwaggerGen maps OpenAPI metadata to Swashbuckle attributes:

| OpenAPI Property | Swashbuckle Attribute | Description |
|------------------|----------------------|-------------|
| `description` | `[SwaggerSchema(Description = "...")]` | Property description for documentation |
| `format` | `[SwaggerSchema(Format = "...")]` | Data format (e.g., "email", "uuid", "int64") |
| `example` | `[SwaggerExampleValue(...)]` | Example value for documentation |

### Example Output

**Input Swagger Schema:**
```json
{
  "User": {
    "type": "object",
    "properties": {
      "id": {
        "type": "integer",
        "format": "int64",
        "description": "The unique identifier",
        "example": 12345
      },
      "email": {
        "type": "string", 
        "format": "email",
        "description": "User's email address",
        "example": "john.doe@example.com"
      }
    },
    "required": ["id"]
  }
}
```

**Generated C# Code:**
```csharp
using System.ComponentModel.DataAnnotations;
using Newtonsoft.Json;
using Swashbuckle.AspNetCore.Annotations;

namespace Generated;

public partial class User
{
    [JsonProperty("id")]
    [Required]
    [SwaggerSchema(Description = "The unique identifier", Format = "int64")]
    [SwaggerExampleValue(12345)]
    public long Id { get; set; }

    [JsonProperty("email")]
    [SwaggerSchema(Description = "User's email address", Format = "email")]
    [SwaggerExampleValue("john.doe@example.com")]
    public string Email { get; set; }
}
```

### Feature Compatibility

Swashbuckle attributes work alongside all other SwaggerGen features:

```bash
# Combine with modern C# features
jsome generate api.json --swashbuckle-attributes --modern

# Combine with System.Text.Json
jsome generate api.json --swashbuckle-attributes --system-text-json

# Combine with records
jsome generate api.json --swashbuckle-attributes --modern --records
```

**Note:** Swashbuckle attributes are generated *in addition to* existing DataAnnotations, ensuring backward compatibility.

## Output

The generator produces two types of files for each definition in your Swagger spec:

### DTO Classes

```csharp
using System.ComponentModel.DataAnnotations;
using Newtonsoft.Json;

namespace SwaggerGen.Generated;

/// <summary>
/// Customer object description
/// </summary>
public class Customer
{
    [JsonProperty("id")]
    [Required]
    public string Id { get; set; }

    [JsonProperty("email")]
    [MaxLength(512)]
    public string Email { get; set; }

    [JsonProperty("address")]
    public Address Address { get; set; }
}
```

### FluentValidation Validators

```csharp
using FluentValidation;

namespace SwaggerGen.Generated.Validators;

/// <summary>
/// Validator for Customer
/// </summary>
public class CustomerValidator : AbstractValidator<Customer>
{
    public CustomerValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty()
            .Matches("^cus_[a-zA-Z0-9]+$");
            
        RuleFor(x => x.Email)
            .MaximumLength(512);
    }
}
```

## Supported Swagger Features

### Schema Types
- ✅ `string`, `integer`, `number`, `boolean`, `array`, `object`
- ✅ Format specifications (`date-time`, `int64`, `float`, etc.)
- ✅ `$ref` references to other definitions
- ✅ `allOf` for inheritance

### Validation Constraints
- ✅ `required` fields → `[Required]` and `.NotEmpty()`
- ✅ `minLength`/`maxLength` → `[MinLength]`/`[MaxLength]` and validation rules
- ✅ `minimum`/`maximum` → `.GreaterThanOrEqualTo()`/`.LessThanOrEqualTo()`
- ✅ `pattern` → `.Matches()` with regex
- ✅ `enum` values → validation rules

### Complex Scenarios
- ✅ Large schemas (tested with 22+ definitions)
- ✅ Nested object references
- ✅ Arrays with typed items
- ✅ Properties without explicit types (handled gracefully)

## Project Structure

```
SwaggerGen/
├── src/SwaggerGen/                    # Main application
│   ├── CodeGeneration/                # Code generation logic
│   ├── Models/                        # Swagger document models
│   ├── Templates/                     # Handlebars templates
│   ├── Samples/                       # Sample Swagger files
│   ├── Program.cs                     # Console app entry point
│   └── SwaggerParser.cs               # Core parsing logic
├── testdata/                          # Test Swagger files
│   └── stripe-swagger.json            # Complex real-world example
├── tests/SwaggerGen.Tests/            # Unit tests
└── SwaggerGen.sln                     # Solution file
```

## Testing

Run the comprehensive test suite:

```bash
dotnet test
```

The tests include:
- Basic DTO and validator generation
- Complex schema handling (including Stripe API)
- `$ref` reference resolution
- Validation rule generation
- Error handling for edge cases
- Modifier configuration system testing
- YAML and JSON configuration loading
- Property inclusion/exclusion rules
- Custom validation overrides

## Contributing

1. Fork the repository
2. Create a feature branch
3. Add tests for your changes
4. Ensure all tests pass
5. Submit a pull request

## For Maintainers

### Publishing a New Release

This project uses automated NuGet publishing via GitHub Actions. To publish a new version:

1. **Set up the NuGet API Key** (one-time setup):
   - Go to [NuGet.org](https://www.nuget.org/account/apikeys) and create an API key
   - In GitHub, go to repository Settings > Secrets and variables > Actions
   - Add a new secret named `NUGET_API_KEY` with your NuGet API key

2. **Create and push a release tag**:
   ```bash
   # Tag the current commit with version number
   git tag v1.0.0
   git push origin v1.0.0
   ```

3. **Monitor the release**:
   - The GitHub Actions workflow will automatically:
     - Build and test the project
     - Create a NuGet package with the version from the tag
     - Publish to NuGet.org
   - Check the Actions tab to monitor progress
   - The package will be available at: https://www.nuget.org/packages/dotnet-jsome/

### Versioning

- Use semantic versioning (e.g., v1.0.0, v1.1.0, v2.0.0)
- The workflow extracts the version from the git tag (removes the 'v' prefix)
- Pre-release versions can use suffixes (e.g., v1.0.0-beta.1)

### Validation

Before creating a release, you can validate the NuGet publishing setup:

```bash
# Run the validation script
./validate-nuget-setup.sh
```

This script checks:
- Build and test success
- NuGet package creation
- Package contents and structure
- GitHub Actions workflow configuration

### Troubleshooting

If the publishing fails:
1. Check the GitHub Actions logs in the "Actions" tab
2. Verify the `NUGET_API_KEY` secret is correctly set
3. Ensure the tag follows semantic versioning (vX.Y.Z)
4. Run the validation script locally to test package creation

## License

This project is licensed under the MIT License.

## Technologies Used

- **Target Framework**: .NET 8.0
- **JSON Processing**: Newtonsoft.Json for parsing Swagger documents and JSON configurations
- **YAML Processing**: YamlDotNet for parsing YAML configuration files
- **Templating**: HandleBars.Net for code generation templates
- **Testing**: xUnit for unit tests
- **Validation**: FluentValidation for generated validators